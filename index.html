<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ukrainian Combat Tank Always Wins</title>
    <style>
        .hidden {
            display: none !important;
        }
        
        #victory-message, #game-over-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        
        .message-text {
            color: white;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        #victory-message .message-text {
            color: #ffdd00; /* Ukrainian flag yellow */
        }
        
        #game-over-message .message-text {
            color: #ff4444; /* Red for game over */
        }
        
        #restart-button, #restart-button-gameover {
            background-color: #0057b7; /* Ukrainian flag blue */
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #restart-button-gameover {
            background-color: #cc0000; /* Red for game over */
        }
        
        /* Game container and canvas styling */
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        
        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: visible;
            display: flex;
            flex-direction: column;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 520px !important;
            max-height: 520px;
            background-color: #000;
            border-radius: 0;
            position: relative;
            z-index: 0;
            order: 0; /* Canvas after HUD on mobile */
        }
        
        /* Mobile-first: HUD at top to avoid touch control interference */
        #hud {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 10px 5px;
            background-color: rgba(0, 0, 0, 0.9);
            font-family: 'Arial', sans-serif;
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin: 0;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 2px solid #333;
            border-radius: 8px 8px 0 0;
            position: static !important;
            z-index: 1;
            order: -1; /* Place HUD before canvas on mobile */
        }
        
        #score, #lives, #btn {
            margin: 0 15px;
        }
        
        /* Loading screen styling */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            display: none; /* Hidden by default, shown by JavaScript */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            cursor: pointer;
        }
        
        #loading-screen h2 {
            color: #ffdd00;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #loading-screen p {
            font-size: 1.2em;
            margin: 10px 0;
            color: #0057b7;
        }
        
        #loading-screen p:last-child {
            color: #ffdd00;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #score {
            color: #ffdd00; /* Ukrainian flag yellow */
        }
        
        #lives {
            color: #0057b7; /* Ukrainian flag blue */
        }

        #btn {
            color: aquamarine;
        }
        
        /* Game controls (fullscreen and sound toggles) */
        .game-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .toggle-btn {
            background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
            border: 2px solid #666;
            border-radius: 6px;
            padding: 6px 10px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 80px;
            justify-content: center;
        }
        
        .toggle-btn:hover {
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            border-color: #777;
        }
        
        .toggle-btn.active {
            background: linear-gradient(145deg, #ffdd00, #e6c400);
            color: #000;
            border-color: #ffdd00;
        }
        
        .toggle-btn.info {
            background: linear-gradient(145deg, #ffdd00, #e6c400);
            color: #000;
            border-color: #ffdd00;
            cursor: default;
            font-weight: bold;
        }
        
        .toggle-btn.info:hover {
            background: linear-gradient(145deg, #ffdd00, #e6c400);
            border-color: #ffdd00;
        }
        
        .toggle-btn.paused {
            background: linear-gradient(145deg, #ff9900, #e68a00);
            color: white;
            border-color: #ff9900;
        }
        
        @media (max-width: 768px) {
            #hud {
                font-size: 14px;
                padding: 12px 5px;
                gap: 8px;
            }
            
            #gameCanvas {
                height: auto !important; /* Override fixed height on mobile */
                max-height: 60vh !important; /* Limit height to 60% of viewport */
                aspect-ratio: 4/3 !important; /* Maintain proper aspect ratio */
                width: 100% !important;
            }
            
            .toggle-btn {
                font-size: 11px;
                padding: 4px 6px;
                min-width: 55px;
            }
            
            .toggle-btn.info {
                font-size: 9px;
                padding: 4px 5px;
                min-width: auto;
            }
            
            #score, #lives, #btn {
                margin: 0 5px;
                font-size: 13px;
            }
            
            .game-controls {
                gap: 6px;
            }
        }
        
        /* Desktop styles - HUD at bottom to avoid overlap */
        @media (min-width: 769px) {
            #game-container {
                max-width: 800px;
                display: flex;
                flex-direction: column;
            }
            
            #gameCanvas {
                width: 100% !important;
                height: 520px !important;
                max-width: 800px;
                display: block;
                position: relative;
                z-index: 0;
                order: 0; /* Canvas first on desktop */
                border-radius: 8px 8px 0 0;
            }
            
            #hud {
                width: 100%;
                max-width: 800px;
                margin: 10px auto 0 auto;
                padding: 15px 10px;
                position: static;
                display: flex;
                font-size: 18px;
                gap: 15px;
                order: 1; /* HUD after canvas on desktop */
                border-top: 3px solid #333;
                border-bottom: none;
                border-radius: 0 0 8px 8px;
                /* Ensure it's completely separate from canvas */
                top: auto;
                left: auto;
                right: auto;
                bottom: auto;
            }
            
            .toggle-btn {
                font-size: 14px;
                padding: 6px 10px;
                min-width: 80px;
            }
            
            .toggle-btn.info {
                font-size: 12px;
                padding: 6px 8px;
            }
            
            #score, #lives {
                margin: 0 15px;
                font-size: 18px;
            }
        }
        
        /* Controls info */
        #controls-info {
            text-align: center;
            color: white;
            padding: 15px;
            font-size: 14px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .controls-section {
            margin: 10px 0;
        }
        
        .controls-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffdd00;
            margin-bottom: 8px;
        }
        
        .control-group {
            display: inline-block;
            margin: 0 15px;
            vertical-align: top;
        }
        
        .control-keys {
            display: flex;
            justify-content: center;
            gap: 2px;
            margin-bottom: 5px;
        }
        
        .key {
            display: inline-block;
            background: linear-gradient(145deg, #4a4a4a, #2a2a2a);
            border: 2px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            font-family: monospace;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            min-width: 20px;
            text-align: center;
            font-size: 12px;
            transition: all 0.1s ease;
        }
        
        .key.pressed {
            background: linear-gradient(145deg, #ffdd00, #e6c400);
            color: #000;
            border-color: #ffdd00;
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transform: translateY(1px);
        }
        
        .key.space {
            padding: 4px 16px;
        }
        
        .control-label {
            font-size: 12px;
            color: #ccc;
            font-weight: bold;
        }
        
        .mobile-note {
            margin-top: 10px;
            font-size: 12px;
            color: #0057b7;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .control-group {
                display: block;
                margin: 10px 0;
            }
            
            .controls-title {
                font-size: 14px;
            }
        }
    </style>
    <link rel="stylesheet" href="mobile.css">
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="victory-message" class="hidden">
            <div class="message-text">It's a win🇺🇦🇺🇦🇺🇦</div>
            <button id="restart-button">Play Again</button>
        </div>
        <div id="game-over-message" class="hidden">
            <div class="message-text">Game over💥</div>
            <button id="restart-button-gameover">Play Again</button>
        </div>
        <div id="hud">
            <div id="score">Score: 0 (Enemies: 0/10)</div>
            <div id="lives">Lives: 3</div>
            <div class="game-controls">
                <div class="toggle-btn info">
                    <span>🎮</span> WASD/↑↓←→ + SPACE
                </div>
                <button id="pause-btn" class="toggle-btn">
                    <span>⏸️</span> Pause
                </button>
                <button id="fullscreen-btn" class="toggle-btn">
                    <span>🔳</span> Fullscreen
                </button>
                <button id="sound-btn" class="toggle-btn active">
                    <span>🔊</span> Sound
                </button>
            </div>
        </div>
        <div id="controls-info">
            <div class="controls-title">🎮 Game Controls</div>
            <div class="controls-section">
                <div class="control-group">
                    <div class="control-keys">
                        <span class="key">W</span>
                        <span class="key">A</span>
                        <span class="key">S</span>
                        <span class="key">D</span>
                    </div>
                    <div class="control-label">Movement</div>
                </div>
                
                <div class="control-group">
                    <div class="control-keys">
                        <span class="key">↑</span>
                        <span class="key">←</span>
                        <span class="key">↓</span>
                        <span class="key">→</span>
                    </div>
                    <div class="control-label">Arrow Keys</div>
                </div>
                
                <div class="control-group">
                    <div class="control-keys">
                        <span class="key space">Space</span>
                    </div>
                    <div class="control-label">Fire</div>
                </div>
            </div>
            <div class="mobile-note">📱 Touch controls available on mobile devices</div>
        </div>
    </div>
    
    <!-- Loading screen -->
    <div id="loading-screen">
        <h2>Ukrainian Combat Tank</h2>
        <p>Loading game...</p>
        <p>Tap to start</p>
    </div>

    <script src="mobile.js"></script>
    <script>
        // Canvas setup with error handling
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Check if canvas context is available
        if (!ctx) {
            console.error('Canvas 2D context not available');
            alert('Canvas not supported on this device');
        }
        
        // Set canvas size - reduced height to make room for HUD
        canvas.width = 800;
        canvas.height = 520; // Further reduced from 550 to 520 for more clearance
        
        // Set canvas background to ensure it's visible
        canvas.style.backgroundColor = '#000000';
        
        // Test canvas immediately to verify it works
        function testCanvas() {
            try {
                console.log('Testing canvas...');
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(0, 0, 100, 100);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(100, 100, 100, 100);
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(200, 200, 100, 100);
                console.log('Canvas test successful - colored squares should be visible');
                
                // Add text to verify canvas is working
                ctx.fillStyle = '#ffffff';
                ctx.font = '20px Arial';
                ctx.fillText('Canvas Working!', 50, 350);
                
                return true;
            } catch (error) {
                console.error('Canvas test failed:', error);
                return false;
            }
        }
        
        // Run canvas test immediately
        if (testCanvas()) {
            console.log('Initial canvas test passed');
        } else {
            console.error('Initial canvas test failed');
        }

        // Game constants
        const GRID_SIZE = 40;
        const TANK_SIZE = 35;
        const BULLET_SIZE = 8;
        const BULLET_SPEED = 7;
        const PLAYER_SPEED = 4;
        const ENEMY_SPEED = 2;
        const ENEMY_SHOOT_CHANCE = 0.01;
        let MAX_ENEMIES = 3; // Maximum enemies on screen at once
        let TOTAL_ENEMIES_TO_DEFEAT = 10; // Total number of enemies to defeat for victory
        let TOTAL_ENEMIES_SPAWNED = 0; // Track how many enemies have been spawned

        // Colors
        const COLORS = {
            playerBlue: '#0057b7',  // Ukrainian flag blue
            playerYellow: '#ffdd00', // Ukrainian flag yellow
            enemy: '#cc0000',
            enemyDark: '#990000',
            wall: '#964B00',
            wallDark: '#7a3b00',
            base: '#0057b7',
            bullet: '#ffffff',
            explosion: '#ff9900',
            background: '#1a1a1a',
            text: '#ffffff'
        };

        // Key states - make it globally accessible for mobile.js
        window.keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            space: false,
            arrowUp: false,
            arrowDown: false,
            arrowLeft: false,
            arrowRight: false
        };

        // Game state
        let gameRunning = true;
        let gameOver = false;
        let gamePaused = false;
        let victory = false;
        let score = 0;
        let lives = 3;
        let enemiesDefeated = 0;
        let totalEnemiesSpawned = 0;

        // DOM elements
        const victoryMessage = document.getElementById('victory-message');
        const gameOverMessage = document.getElementById('game-over-message');
        const restartButton = document.getElementById('restart-button');
        const restartButtonGameover = document.getElementById('restart-button-gameover');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const loadingScreen = document.getElementById('loading-screen');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const soundBtn = document.getElementById('sound-btn');
        const pauseBtn = document.getElementById('pause-btn');
    </script>
    </script>
    <script>
        // Audio setup
        class GameAudio {
            constructor() {
                this.audioContext = null;
                this.sounds = {
                    shoot: null,
                    explosion: null,
                    victory: null
                };
                this.initialized = false;
                this.enabled = true; // Sound enabled by default
                
                // Initialize audio on user interaction
                document.addEventListener('click', () => this.initAudio(), { once: true });
                document.addEventListener('keydown', () => this.initAudio(), { once: true });
            }
            
            initAudio() {
                if (this.initialized) return;
                
                try {
                    // Create audio context
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                    
                    // Create sounds
                    this.createShootSound();
                    this.createExplosionSound();
                    this.createVictorySound();
                    
                    this.initialized = true;
                    console.log('Audio initialized');
                } catch (e) {
                    console.error('Web Audio API not supported:', e);
                }
            }
            
            createShootSound() {
                const duration = 0.2;
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(220, this.audioContext.currentTime + duration);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                this.sounds.shoot = {
                    play: () => {
                        if (!this.initialized) return;
                        
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(220, this.audioContext.currentTime + duration);
                        
                        gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + duration);
                    }
                };
            }
            
            createExplosionSound() {
                const duration = 0.5;
                
                this.sounds.explosion = {
                    play: () => {
                        if (!this.initialized) return;
                        
                        const bufferSize = this.audioContext.sampleRate * duration;
                        const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        
                        for (let i = 0; i < bufferSize; i++) {
                            data[i] = Math.random() * 2 - 1;
                            data[i] *= (1 - (i / bufferSize)); // Fade out
                        }
                        
                        const source = this.audioContext.createBufferSource();
                        const gainNode = this.audioContext.createGain();
                        
                        source.buffer = buffer;
                        gainNode.gain.value = 0.5;
                        
                        source.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        source.start();
                    }
                };
            }
            
            createVictorySound() {
                const duration = 1.0;
                
                this.sounds.victory = {
                    play: () => {
                        if (!this.initialized) return;
                        
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(440, this.audioContext.currentTime);
                        osc.frequency.linearRampToValueAtTime(880, this.audioContext.currentTime + duration);
                        
                        gain.gain.setValueAtTime(0.7, this.audioContext.currentTime);
                        gain.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                        
                        osc.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.start();
                        osc.stop(this.audioContext.currentTime + duration);
                        
                        // Add a second tone for harmony
                        setTimeout(() => {
                            const osc2 = this.audioContext.createOscillator();
                            const gain2 = this.audioContext.createGain();
                            
                            osc2.type = 'sine';
                            osc2.frequency.setValueAtTime(660, this.audioContext.currentTime);
                            osc2.frequency.linearRampToValueAtTime(1320, this.audioContext.currentTime + 0.8);
                            
                            gain2.gain.setValueAtTime(0.5, this.audioContext.currentTime);
                            gain2.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 0.8);
                            
                            osc2.connect(gain2);
                            gain2.connect(this.audioContext.destination);
                            
                            osc2.start();
                            osc2.stop(this.audioContext.currentTime + 0.8);
                        }, 200);
                    }
                };
            }
            
            playSound(soundName) {
                if (this.enabled && this.sounds[soundName]) {
                    this.sounds[soundName].play();
                }
            }
            
            toggleSound() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
            
            isSoundEnabled() {
                return this.enabled;
            }
        }

        // Create audio instance
        const gameAudio = new GameAudio();
    </script>
    <script>
        // Game objects

        // Tank class
        class Tank {
            constructor(x, y, direction, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.width = TANK_SIZE;
                this.height = TANK_SIZE;
                this.direction = direction;
                this.isPlayer = isPlayer;
                this.lastShot = 0;
                this.cooldown = 500; // milliseconds
                this.moveCounter = 0;
                this.moveTime = Math.floor(Math.random() * 60) + 30;
                this.defeated = false;
            }
            
            get rect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            move(dx, dy, walls, base, tanks) {
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                // Update direction based on movement
                if (dx > 0) this.direction = "right";
                else if (dx < 0) this.direction = "left";
                else if (dy > 0) this.direction = "down";
                else if (dy < 0) this.direction = "up";
                
                // Check collision with walls and boundaries
                const newRect = {
                    x: newX,
                    y: newY,
                    width: this.width,
                    height: this.height
                };
                
                // Check boundaries
                if (newX < 0 || newX + this.width > canvas.width || 
                    newY < 0 || newY + this.height > canvas.height) {
                    return false;
                }
                
                // Check collision with walls
                for (const wall of walls) {
                    if (checkCollision(newRect, wall.rect)) {
                        return false;
                    }
                }
                
                // Check collision with base
                if (checkCollision(newRect, base.rect)) {
                    return false;
                }
                
                // Check collision with other tanks
                for (const tank of tanks) {
                    if (tank !== this && checkCollision(newRect, tank.rect)) {
                        return false;
                    }
                }
                
                // If no collisions, update position
                this.x = newX;
                this.y = newY;
                return true;
            }
            
            shoot(bullets, currentTime) {
                if (currentTime - this.lastShot > this.cooldown) {
                    this.lastShot = currentTime;
                    
                    // Calculate bullet position based on tank direction and position
                    let bulletX = this.x + this.width / 2;
                    let bulletY = this.y + this.height / 2;
                    
                    bullets.push(new Bullet(bulletX, bulletY, this.direction, this.isPlayer));
                    gameAudio.playSound('shoot');
                    return true;
                }
                return false;
            }
            
            draw() {
                // Save context for rotation
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                
                // Rotate based on direction
                let rotation = 0;
                if (this.direction === "right") rotation = Math.PI / 2;
                else if (this.direction === "down") rotation = Math.PI;
                else if (this.direction === "left") rotation = -Math.PI / 2;
                
                ctx.rotate(rotation);
                
                if (this.isPlayer) {
                    // Draw Ukrainian tank (blue and yellow)
                    // Tank body (yellow)
                    ctx.fillStyle = COLORS.playerYellow;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Tank top (blue)
                    ctx.fillStyle = COLORS.playerBlue;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height / 2);
                    
                    // Tank cannon
                    ctx.fillStyle = COLORS.playerBlue;
                    ctx.fillRect(-2, -this.height / 2 - 8, 4, 8);
                    
                    // Tank treads
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-this.width / 2 - 2, -this.height / 2, 2, this.height);
                    ctx.fillRect(this.width / 2, -this.height / 2, 2, this.height);
                } else {
                    // Draw enemy tank (red)
                    // Tank body
                    ctx.fillStyle = COLORS.enemy;
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Tank top
                    ctx.fillStyle = COLORS.enemyDark;
                    ctx.fillRect(-this.width / 2 + 4, -this.height / 2 + 4, this.width - 8, this.height - 8);
                    
                    // Tank cannon
                    ctx.fillStyle = COLORS.enemyDark;
                    ctx.fillRect(-2, -this.height / 2 - 8, 4, 8);
                    
                    // Tank treads
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-this.width / 2 - 2, -this.height / 2, 2, this.height);
                    ctx.fillRect(this.width / 2, -this.height / 2, 2, this.height);
                    
                    if (this.defeated) {
                        // Draw fire emoji if defeated
                        ctx.fillStyle = COLORS.text;
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🔥', 0, 0);
                    } else {
                        // Draw skull symbol
                        ctx.fillStyle = COLORS.text;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-2, -1, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(2, -1, 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(-3, 2);
                        ctx.lineTo(3, 2);
                        ctx.lineTo(2, 4);
                        ctx.lineTo(-2, 4);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // Restore context
                ctx.restore();
            }
        }

        // Bullet class
        class Bullet {
            constructor(x, y, direction, isPlayer) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.isPlayer = isPlayer;
            }
            
            get rect() {
                return {
                    x: this.x - BULLET_SIZE / 2,
                    y: this.y - BULLET_SIZE / 2,
                    width: BULLET_SIZE,
                    height: BULLET_SIZE
                };
            }
            
            update() {
                if (this.direction === "up") this.y -= BULLET_SPEED;
                else if (this.direction === "right") this.x += BULLET_SPEED;
                else if (this.direction === "down") this.y += BULLET_SPEED;
                else if (this.direction === "left") this.x -= BULLET_SPEED;
            }
            
            draw() {
                ctx.fillStyle = COLORS.bullet;
                ctx.fillRect(
                    this.x - BULLET_SIZE / 2,
                    this.y - BULLET_SIZE / 2,
                    BULLET_SIZE,
                    BULLET_SIZE
                );
            }
        }

        // Wall class
        class Wall {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = GRID_SIZE;
                this.height = GRID_SIZE;
            }
            
            get rect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            draw() {
                ctx.fillStyle = COLORS.wall;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw brick pattern
                ctx.strokeStyle = COLORS.wallDark;
                ctx.lineWidth = 1;
                
                // Horizontal lines
                for (let i = 1; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + i * this.height / 4);
                    ctx.lineTo(this.x + this.width, this.y + i * this.height / 4);
                    ctx.stroke();
                }
                
                // Vertical lines - offset every other row
                for (let i = 0; i < 4; i++) {
                    const offset = i % 2 === 0 ? 0 : this.width / 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.x + offset, this.y + i * this.height / 4);
                    ctx.lineTo(this.x + offset, this.y + (i + 1) * this.height / 4);
                    ctx.stroke();
                    
                    if (offset === 0) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + this.width / 2, this.y + i * this.height / 4);
                        ctx.lineTo(this.x + this.width / 2, this.y + (i + 1) * this.height / 4);
                        ctx.stroke();
                    }
                }
            }
        }

        // Base class (Crimean peninsula)
        class Base {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            get rect() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            draw() {
                ctx.fillStyle = COLORS.base;
                
                // Draw a simplified Crimean peninsula shape
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + this.height * 0.3);
                ctx.lineTo(this.x + this.width * 0.2, this.y + this.height * 0.1);
                ctx.lineTo(this.x + this.width * 0.5, this.y);
                ctx.lineTo(this.x + this.width * 0.8, this.y + this.height * 0.2);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.4);
                ctx.lineTo(this.x + this.width * 0.9, this.y + this.height * 0.7);
                ctx.lineTo(this.x + this.width * 0.7, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.3, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.1, this.y + this.height * 0.8);
                ctx.closePath();
                ctx.fill();
                
                // Draw a yellow star
                ctx.fillStyle = COLORS.playerYellow;
                const starX = this.x + this.width * 0.5;
                const starY = this.y + this.height * 0.5;
                const starSize = 10;
                
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                    const x = starX + Math.cos(angle) * starSize;
                    const y = starY + Math.sin(angle) * starSize;
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
            }
        }

        // Explosion class
        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 15;
                this.maxRadius = 15;
                this.life = 15;
            }
            
            update() {
                this.life--;
                this.radius = (this.life / 15) * this.maxRadius;
            }
            
            draw() {
                ctx.fillStyle = COLORS.explosion;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Utility function to check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }
    </script>
    <script>
        // Game mechanics

        // Game objects
        let player;
        let enemies = [];
        let bullets = [];
        let walls = [];
        let explosions = [];
        let base;

        // Initialize game objects
        function initGame() {
            // Ensure canvas dimensions are set correctly for mobile
            if (window.innerWidth <= 768) {
                // Mobile: Set canvas internal dimensions based on display size
                const displayWidth = canvas.clientWidth;
                const displayHeight = canvas.clientHeight;
                
                if (displayWidth && displayHeight) {
                    canvas.width = displayWidth;
                    canvas.height = displayHeight;
                    console.log('Mobile canvas dimensions set to:', canvas.width, 'x', canvas.height);
                }
            }
            
            // Create player
            player = new Tank(
                canvas.width / 2 - TANK_SIZE / 2,
                canvas.height - GRID_SIZE * 3,
                "up",
                true
            );
            
            // Create base
            base = new Base(
                canvas.width / 2 - GRID_SIZE * 1.5,
                canvas.height - GRID_SIZE * 2,
                GRID_SIZE * 3,
                GRID_SIZE * 1.5
            );
            
            // Initialize walls
            initWalls();
            
            // Reset game state
            enemies = [];
            bullets = [];
            explosions = [];
            gameRunning = true;
            gameOver = false;
            gamePaused = false;
            victory = false;
            score = 0;
            lives = 3;
            enemiesDefeated = 0;
            totalEnemiesSpawned = 0;
            
            // Reset pause button
            pauseBtn.classList.remove('paused');
            pauseBtn.innerHTML = '<span>⏸️</span> Pause';
            
            // Update HUD
            updateHUD();
            
            // Hide messages
            victoryMessage.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
        }

        // Initialize walls
        function initWalls() {
            walls = [];
            
            // Border walls
            for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                walls.push(new Wall(x, 0));
                walls.push(new Wall(x, canvas.height - GRID_SIZE));
            }
            
            for (let y = GRID_SIZE; y < canvas.height - GRID_SIZE; y += GRID_SIZE) {
                walls.push(new Wall(0, y));
                walls.push(new Wall(canvas.width - GRID_SIZE, y));
            }
            
            // Random walls in the middle
            for (let i = 0; i < 40; i++) {
                const x = Math.floor(Math.random() * (canvas.width / GRID_SIZE - 2) + 1) * GRID_SIZE;
                const y = Math.floor(Math.random() * (canvas.height / GRID_SIZE - 6) + 1) * GRID_SIZE;
                
                // Don't place walls too close to the player starting position
                if (Math.abs(x - player.x) > GRID_SIZE * 2 || Math.abs(y - player.y) > GRID_SIZE * 2) {
                    walls.push(new Wall(x, y));
                }
            }
            
            // Walls around the base
            const baseX = base.x - GRID_SIZE;
            const baseY = base.y - GRID_SIZE;
            
            walls.push(new Wall(baseX, baseY));
            walls.push(new Wall(baseX + GRID_SIZE, baseY));
            walls.push(new Wall(baseX + GRID_SIZE * 2, baseY));
            walls.push(new Wall(baseX + GRID_SIZE * 3, baseY));
            walls.push(new Wall(baseX + GRID_SIZE * 4, baseY));
            
            walls.push(new Wall(baseX, baseY + GRID_SIZE));
            walls.push(new Wall(baseX + GRID_SIZE * 4, baseY + GRID_SIZE));
            
            walls.push(new Wall(baseX, baseY + GRID_SIZE * 2));
            walls.push(new Wall(baseX + GRID_SIZE * 4, baseY + GRID_SIZE * 2));
        }

        // Spawn enemy
        function spawnEnemy() {
            // Only spawn if we haven't reached the total number of enemies to defeat
            if (enemies.length < MAX_ENEMIES && totalEnemiesSpawned < TOTAL_ENEMIES_TO_DEFEAT) {
                const spawnPoints = [
                    { x: GRID_SIZE, y: GRID_SIZE },
                    { x: canvas.width - GRID_SIZE * 2, y: GRID_SIZE },
                    { x: canvas.width / 2 - GRID_SIZE / 2, y: GRID_SIZE }
                ];
                
                const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                enemies.push(new Tank(spawnPoint.x, spawnPoint.y, "down"));
                totalEnemiesSpawned++;
            }
        }

        // Handle player movement
        function handlePlayerMovement() {
            if (!gameRunning) return;
            
            let dx = 0;
            let dy = 0;
            
            // Check key states for movement
            if (keys.w || keys.arrowUp) dy = -PLAYER_SPEED;
            else if (keys.s || keys.arrowDown) dy = PLAYER_SPEED;
            else if (keys.a || keys.arrowLeft) dx = -PLAYER_SPEED;
            else if (keys.d || keys.arrowRight) dx = PLAYER_SPEED;
            
            // Move player if keys are pressed
            if (dx !== 0 || dy !== 0) {
                player.move(dx, dy, walls, base, enemies);
            }
            
            // Handle shooting
            if (keys.space) {
                player.shoot(bullets, Date.now());
            }
        }

        // Update enemies
        function updateEnemies() {
            if (gameOver) return;
            
            for (const enemy of enemies) {
                if (enemy.defeated) continue;
                
                // Move counter for changing direction
                enemy.moveCounter++;
                
                if (enemy.moveCounter >= enemy.moveTime) {
                    enemy.moveCounter = 0;
                    enemy.moveTime = Math.floor(Math.random() * 60) + 30;
                    enemy.direction = ["up", "right", "down", "left"][Math.floor(Math.random() * 4)];
                }
                
                // Move enemy
                let dx = 0;
                let dy = 0;
                
                if (enemy.direction === "up") dy = -ENEMY_SPEED;
                else if (enemy.direction === "right") dx = ENEMY_SPEED;
                else if (enemy.direction === "down") dy = ENEMY_SPEED;
                else if (enemy.direction === "left") dx = -ENEMY_SPEED;
                
                if (!enemy.move(dx, dy, walls, base, [player, ...enemies])) {
                    // If can't move, change direction
                    enemy.direction = ["up", "right", "down", "left"][Math.floor(Math.random() * 4)];
                }
                
                // Random shooting
                if (Math.random() < ENEMY_SHOOT_CHANCE && !enemy.defeated) {
                    enemy.shoot(bullets, Date.now());
                }
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.update();
                
                // Check if bullet is out of bounds
                if (bullet.x < 0 || bullet.x > canvas.width ||
                    bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with walls
                for (let j = walls.length - 1; j >= 0; j--) {
                    if (checkCollision(bullet.rect, walls[j].rect)) {
                        explosions.push(new Explosion(bullet.x, bullet.y));
                        gameAudio.playSound('explosion');
                        walls.splice(j, 1);
                        bullets.splice(i, 1);
                        break;
                    }
                }
                
                // Skip if bullet was removed
                if (i >= bullets.length) continue;
                
                // Check collision with base
                if (checkCollision(bullet.rect, base.rect)) {
                    if (!bullet.isPlayer) {
                        // Game over if enemy hits the base
                        declareGameOver();
                    }
                    
                    explosions.push(new Explosion(bullet.x, bullet.y));
                    gameAudio.playSound('explosion');
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with player
                if (!bullet.isPlayer && checkCollision(bullet.rect, player.rect)) {
                    explosions.push(new Explosion(bullet.x, bullet.y));
                    gameAudio.playSound('explosion');
                    bullets.splice(i, 1);
                    
                    // Decrease lives
                    lives--;
                    updateHUD();
                    
                    if (lives <= 0) {
                        // Player has lost all lives - Game Over
                        declareGameOver();
                    } else {
                        // Reset player position
                        player.x = canvas.width / 2 - TANK_SIZE / 2;
                        player.y = canvas.height - GRID_SIZE * 3;
                        player.direction = "up";
                    }
                    
                    continue;
                }
                
                // Check collision with enemies
                if (bullet.isPlayer) {
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (!enemy.defeated && checkCollision(bullet.rect, enemy.rect)) {
                            explosions.push(new Explosion(bullet.x, bullet.y));
                            gameAudio.playSound('explosion');
                            
                            // Mark enemy as defeated
                            enemy.defeated = true;
                            
                            // Remove bullet
                            bullets.splice(i, 1);
                            
                            // Increase score
                            score += 10;
                            enemiesDefeated++;
                            updateHUD();
                            
                            // Remove enemy after a delay
                            setTimeout(() => {
                                const index = enemies.indexOf(enemy);
                                if (index > -1) {
                                    enemies.splice(index, 1);
                                }
                                
                                // Check if player has defeated enough enemies
                                if (enemiesDefeated >= TOTAL_ENEMIES_TO_DEFEAT && totalEnemiesSpawned >= TOTAL_ENEMIES_TO_DEFEAT) {
                                    // Make sure no enemies are left on screen
                                    if (enemies.length > 0) {
                                        // Mark all remaining enemies as defeated
                                        for (const enemy of enemies) {
                                            enemy.defeated = true;
                                        }
                                        
                                        // Clear the enemies array after a short delay
                                        setTimeout(() => {
                                            enemies = [];
                                            declareVictory();
                                        }, 500);
                                    } else {
                                        declareVictory();
                                    }
                                }
                            }, 500);
                            
                            break;
                        }
                    }
                }
            }
        }

        // Update explosions
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].update();
                if (explosions[i].life <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        // Declare victory
        // Check if all enemies are defeated
        function checkVictory() {
            if (gameOver) return;
            
            // If player has defeated all enemies (all 10 enemies)
            if (enemiesDefeated >= TOTAL_ENEMIES_TO_DEFEAT && totalEnemiesSpawned >= TOTAL_ENEMIES_TO_DEFEAT) {
                // Make sure no enemies are left on screen
                if (enemies.length > 0) {
                    // Mark all remaining enemies as defeated
                    for (const enemy of enemies) {
                        enemy.defeated = true;
                    }
                    
                    // Clear the enemies array after a short delay
                    setTimeout(() => {
                        enemies = [];
                        declareVictory();
                    }, 500);
                } else {
                    declareVictory();
                }
            }
        }
        
        // Declare victory (when player destroys all enemies)
        function declareVictory() {
            gameRunning = false;
            gameOver = true;
            victory = true;
            
            // Mark all enemies as defeated
            for (const enemy of enemies) {
                enemy.defeated = true;
            }
            
            // Show victory message
            victoryMessage.classList.remove('hidden');
            gameOverMessage.classList.add('hidden');
            
            // Play victory sound
            gameAudio.playSound('victory');
        }
        
        // Declare game over (when player loses all lives or base is destroyed)
        function declareGameOver() {
            gameRunning = false;
            gameOver = true;
            victory = false;
            
            // Show game over message
            gameOverMessage.classList.remove('hidden');
            victoryMessage.classList.add('hidden');
            
            // Play explosion sound
            gameAudio.playSound('explosion');
        }

        // Update HUD
        function updateHUD() {
            scoreDisplay.textContent = `Score: ${score} (Enemies: ${enemiesDefeated}/${TOTAL_ENEMIES_TO_DEFEAT})`;
            livesDisplay.textContent = `Lives: ${lives}`;
        }
    </script>
    <script>
        // Main game loop and event handlers

        // Event listeners for keyboard
        document.addEventListener('keydown', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': window.keys.w = true; highlightKey('W'); break;
                case 'a': window.keys.a = true; highlightKey('A'); break;
                case 's': window.keys.s = true; highlightKey('S'); break;
                case 'd': window.keys.d = true; highlightKey('D'); break;
                case ' ': window.keys.space = true; highlightKey('Space'); e.preventDefault(); break;
                case 'arrowup': window.keys.arrowUp = true; highlightKey('↑'); e.preventDefault(); break;
                case 'arrowdown': window.keys.arrowDown = true; highlightKey('↓'); e.preventDefault(); break;
                case 'arrowleft': window.keys.arrowLeft = true; highlightKey('←'); e.preventDefault(); break;
                case 'arrowright': window.keys.arrowRight = true; highlightKey('→'); e.preventDefault(); break;
                case 'r': 
                    if (gameOver) {
                        initGame();
                    }
                    break;
                case 'p':
                case 'escape':
                    if (!gameOver) {
                        gamePaused = !gamePaused;
                        if (gamePaused) {
                            pauseBtn.classList.add('paused');
                            pauseBtn.innerHTML = '<span>▶️</span> Resume';
                        } else {
                            pauseBtn.classList.remove('paused');
                            pauseBtn.innerHTML = '<span>⏸️</span> Pause';
                        }
                    }
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': window.keys.w = false; unhighlightKey('W'); break;
                case 'a': window.keys.a = false; unhighlightKey('A'); break;
                case 's': window.keys.s = false; unhighlightKey('S'); break;
                case 'd': window.keys.d = false; unhighlightKey('D'); break;
                case ' ': window.keys.space = false; unhighlightKey('Space'); break;
                case 'arrowup': window.keys.arrowUp = false; unhighlightKey('↑'); break;
                case 'arrowdown': window.keys.arrowDown = false; unhighlightKey('↓'); break;
                case 'arrowleft': window.keys.arrowLeft = false; unhighlightKey('←'); break;
                case 'arrowright': window.keys.arrowRight = false; unhighlightKey('→'); break;
            }
        });

        // Visual feedback functions for key presses
        function highlightKey(keyText) {
            const keys = document.querySelectorAll('.key');
            keys.forEach(key => {
                if (key.textContent === keyText) {
                    key.classList.add('pressed');
                }
            });
        }

        function unhighlightKey(keyText) {
            const keys = document.querySelectorAll('.key');
            keys.forEach(key => {
                if (key.textContent === keyText) {
                    key.classList.remove('pressed');
                }
            });
        }

        // Restart button event listeners
        restartButton.addEventListener('click', () => {
            initGame();
        });
        
        restartButtonGameover.addEventListener('click', () => {
            initGame();
        });

        // Fullscreen toggle
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    fullscreenBtn.classList.add('active');
                    fullscreenBtn.innerHTML = '<span>🔲</span> Exit Fullscreen';
                }).catch(err => {
                    console.log('Error attempting to enable fullscreen:', err);
                });
            } else {
                document.exitFullscreen().then(() => {
                    fullscreenBtn.classList.remove('active');
                    fullscreenBtn.innerHTML = '<span>🔳</span> Fullscreen';
                }).catch(err => {
                    console.log('Error attempting to exit fullscreen:', err);
                });
            }
        });

        // Listen for fullscreen changes (e.g., ESC key)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenBtn.classList.remove('active');
                fullscreenBtn.innerHTML = '<span>🔳</span> Fullscreen';
            }
        });

        // Sound toggle
        soundBtn.addEventListener('click', () => {
            const soundEnabled = gameAudio.toggleSound();
            if (soundEnabled) {
                soundBtn.classList.remove('sound-off');
                soundBtn.classList.add('active');
                soundBtn.innerHTML = '<span>🔊</span> Sound';
            } else {
                soundBtn.classList.remove('active');
                soundBtn.classList.add('sound-off');
                soundBtn.innerHTML = '<span>🔇</span> Muted';
            }
        });

        // Pause toggle
        pauseBtn.addEventListener('click', () => {
            gamePaused = !gamePaused;
            if (gamePaused) {
                pauseBtn.classList.add('paused');
                pauseBtn.innerHTML = '<span>▶️</span> Resume';
            } else {
                pauseBtn.classList.remove('paused');
                pauseBtn.innerHTML = '<span>⏸️</span> Pause';
            }
        });

        // Game loop
        function gameLoop() {
            // Debug: Log canvas dimensions on first run
            if (!gameLoop.debugLogged) {
                console.log('Canvas dimensions:', canvas.width, 'x', canvas.height);
                console.log('Canvas style:', canvas.style.width, 'x', canvas.style.height);
                console.log('Canvas client size:', canvas.clientWidth, 'x', canvas.clientHeight);
                console.log('Player position:', player ? player.x + ',' + player.y : 'not created');
                console.log('Base position:', base ? base.x + ',' + base.y : 'not created');
                console.log('Walls count:', walls ? walls.length : 'not created');
                gameLoop.debugLogged = true;
            }
            
            // Ensure canvas context is available
            if (!ctx) {
                console.error('Canvas context lost');
                return;
            }
            
            // Clear canvas with explicit background
            try {
                ctx.fillStyle = COLORS.background || '#2d4a2d';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } catch (error) {
                console.error('Failed to clear canvas:', error);
                return;
            }
            
            // Draw a test rectangle to verify canvas is working (remove after debugging)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(10, 10, 50, 50);
            
            // If game is paused, only draw static elements and show pause message
            if (gamePaused) {
                // Draw static game objects
                try {
                    if (base && typeof base.draw === 'function') base.draw();
                    if (walls && Array.isArray(walls)) {
                        walls.forEach(wall => {
                            if (wall && typeof wall.draw === 'function') wall.draw();
                        });
                    }
                } catch (error) {
                    console.error('Error drawing static objects:', error);
                }
                enemies.forEach(enemy => enemy.draw());
                bullets.forEach(bullet => bullet.draw());
                explosions.forEach(explosion => explosion.draw());
                player.draw();
                
                // Draw pause overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw pause message
                ctx.fillStyle = '#ffdd00';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME PAUSED', canvas.width / 2, canvas.height / 2 - 20);
                
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.fillText('Click Pause button to resume', canvas.width / 2, canvas.height / 2 + 30);
                
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Handle player movement
            handlePlayerMovement();
            
            // Update game objects
            updateEnemies();
            updateBullets();
            updateExplosions();
            
            // Check for victory condition
            checkVictory();
            
            // Spawn enemies
            if (Math.random() < 0.01 && enemies.length < MAX_ENEMIES && totalEnemiesSpawned < TOTAL_ENEMIES_TO_DEFEAT && gameRunning && !gameOver) {
                spawnEnemy();
            }
            
            // Draw game objects with error handling
            try {
                if (base && typeof base.draw === 'function') {
                    base.draw();
                } else {
                    console.warn('Base not available for drawing');
                }
                
                if (walls && Array.isArray(walls)) {
                    for (const wall of walls) {
                        if (wall && typeof wall.draw === 'function') {
                            wall.draw();
                        }
                    }
                } else {
                    console.warn('Walls not available for drawing');
                }
                
                if (bullets && Array.isArray(bullets)) {
                    for (const bullet of bullets) {
                        if (bullet && typeof bullet.draw === 'function') {
                            bullet.draw();
                        }
                    }
                }
                
                if (explosions && Array.isArray(explosions)) {
                    for (const explosion of explosions) {
                        if (explosion && typeof explosion.draw === 'function') {
                            explosion.draw();
                        }
                    }
                }
                
                if (player && typeof player.draw === 'function') {
                    player.draw();
                } else {
                    console.warn('Player not available for drawing');
                }
                
                if (enemies && Array.isArray(enemies)) {
                    for (const enemy of enemies) {
                        if (enemy && typeof enemy.draw === 'function') {
                            enemy.draw();
                        }
                    }
                }
            } catch (error) {
                console.error('Error drawing game objects:', error);
            }
            
            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }

        // Initialize game when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Android-specific initialization
            if (navigator.userAgent.includes('Android')) {
                console.log('Android device detected, applying fixes...');
                
                // Prevent zoom on double tap
                document.addEventListener('touchstart', function(e) {
                    if (e.touches.length > 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Prevent default touch behaviors
                document.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                }, { passive: false });
            }
            
            // Show loading screen first
            loadingScreen.style.display = 'flex';
            
            // Handle loading screen click to start game
            loadingScreen.addEventListener('click', () => {
                loadingScreen.style.display = 'none';
                
                // Mobile-specific canvas setup
                if (window.innerWidth <= 768) {
                    console.log('Setting up mobile canvas...');
                    
                    // Force canvas to match its display size
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    
                    console.log('Mobile canvas setup complete:', canvas.width, 'x', canvas.height);
                    
                    // Test canvas immediately on mobile
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(50, 50, 100, 100);
                    
                    // Wait a moment then initialize game
                    setTimeout(() => {
                        try {
                            initGame();
                            gameLoop();
                            console.log('Mobile game initialized successfully');
                        } catch (error) {
                            console.error('Mobile game initialization failed:', error);
                            alert('Game failed to start on mobile: ' + error.message);
                        }
                    }, 500);
                } else {
                    // Desktop initialization
                    try {
                        initGame();
                        gameLoop();
                        console.log('Desktop game initialized successfully');
                    } catch (error) {
                        console.error('Desktop game initialization failed:', error);
                        alert('Game failed to start: ' + error.message);
                    }
                }
                
                // Initialize audio
                if (window.gameAudio && typeof window.gameAudio.initAudio === 'function') {
                    window.gameAudio.initAudio();
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', handleResize);
            window.addEventListener('orientationchange', () => {
                setTimeout(handleResize, 500); // Delay for orientation change
            });
            handleResize(); // Initial call to set correct size
        });
        
        // Handle window resize with Android compatibility
        function handleResize() {
            // Force canvas redraw after resize
            setTimeout(() => {
                if (window.innerWidth > 768) {
                    // Desktop: Use fixed dimensions
                    const gameContainer = document.getElementById('game-container');
                    const containerWidth = gameContainer.clientWidth;
                    
                    // Use fixed height to prevent HUD overlap
                    const fixedHeight = 520; // Match our canvas.height
                    
                    // Update canvas style with fixed dimensions
                    canvas.style.width = Math.min(containerWidth, 800) + 'px';
                    canvas.style.height = fixedHeight + 'px';
                } else {
                    // Mobile: Use responsive sizing with proper aspect ratio
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                    canvas.style.maxHeight = '60vh';
                    canvas.style.aspectRatio = '4/3';
                    
                    // Android-specific fixes
                    if (navigator.userAgent.includes('Android')) {
                        // Force canvas dimensions for Android
                        const containerWidth = canvas.parentElement.clientWidth;
                        const calculatedHeight = Math.min(containerWidth * 0.75, window.innerHeight * 0.6);
                        canvas.style.width = containerWidth + 'px';
                        canvas.style.height = calculatedHeight + 'px';
                        
                        // Ensure canvas internal dimensions match display size
                        canvas.width = containerWidth;
                        canvas.height = calculatedHeight;
                    }
                }
                
                // Force a redraw
                if (typeof gameLoop === 'function') {
                    requestAnimationFrame(gameLoop);
                }
            }, 100);
        }

        // Initialize game immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            // Show loading screen first
            loadingScreen.style.display = 'flex';
            
            // Handle loading screen click to start game
            loadingScreen.addEventListener('click', () => {
                loadingScreen.style.display = 'none';
                
                // Initialize game after loading screen is dismissed
                initGame();
                gameLoop();
                
                // Initialize audio
                if (window.gameAudio && typeof window.gameAudio.initAudio === 'function') {
                    window.gameAudio.initAudio();
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', handleResize);
            handleResize(); // Initial call to set correct size
        }
    </script>
</body>
</html>
